package inline
func init()  {Root = File{IsDir: true,Name: "template",Children: []File{File{IsDir: true,Name: "page",Children: []File{File{Content: "package page\n\nimport (\n	\"github.com/TobiasYin/go_web_ui/dom\"\n	\"github.com/TobiasYin/go_web_ui/example/component\"\n	\"github.com/TobiasYin/go_web_ui/node\"\n)\n\ntype imagePage struct {\n	title string\n}\n\nfunc (i imagePage)GetPage() *node.Page {\n	return node.NewPage(\"Image\", func(this *node.Context) node.Widget {\n		return node.Column{\n			Alignment: node.Center,\n			Children: []node.Widget{\n				node.Text{\n					Content: \"Page Title: \" + i.title,\n				},\n				node.Text{\n					Content: \"New Page\",\n				},\n				node.Link{\n					Child: node.Text{Content: \"new\"},\n					Href: \"new\",\n				},\n				node.Link{\n					Child: node.Text{Content: \"baidu\"},\n					Href:  \"http://www.baidu.com\",\n				},\n				component.StatefulDemo{\n					Key: node.GenerateKeyWithCallLine(),\n					Value: \"In Page\",\n				},\n				node.BR{},\n				node.Image{\n					Src: \"/example.png\",\n					Params: node.Params{\n						Style: node.Style{\n							Height: node.Size{\n								Value: 100,\n							},\n							Width: node.Size{\n								Value: 100,\n							},\n						},\n					},\n				},\n				node.BR{},\n				node.Button{\n					Child: node.Text{\n						Content: \"back\",\n					},\n					Params: node.Params{\n						OnClick: func(e dom.Event) {\n							node.BackToLastPage()\n						},\n					},\n				},\n			},\n		}\n	})\n}\n\nfunc NewImagePage(m map[string]interface{}) node.PageGetter {\n	n, ok := m[\"title\"]\n	title := \"\"\n	if ok {\n		title, _ = n.(string)\n	}\n	return imagePage{title: title}\n}",Name: "image.go",IsFile: true,}, File{Content: "package page\n\nimport (\n	\"github.com/TobiasYin/go_web_ui/node\"\n	\"github.com/TobiasYin/go_web_ui/tool/template/component\"\n)\n\nfunc GetMainPage() *node.Page {\n	return node.NewPage(\"Main\", func(this *node.Context) node.Widget {\n		return node.Column{\n			Alignment: node.Center,\n			Children: []node.Widget{\n				node.Link{\n					Child: node.Text{Content: \"Image page\"},\n					Href: \"/image\",\n				},\n				node.Text{Content: \"Hello\"},\n				component.StatefulDemo{\n					Key: node.GenerateKeyWithCallLine(),\n					Value: \" Hello \",\n				},\n				component.StatelessDemo{\n					Value: \"World\",\n				},\n			},\n		}\n	})\n}\n",Name: "main.go",IsFile: true,},},}, File{Content: "<!doctype html>\n<html lang=\"zh-cn\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\"\n          content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>{{PROJECT_NAME}}</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"assert/go-ui-basic.css\">\n</head>\n<body>\n<div id=\"app\"></div>\n<script src=\"assert/wasm_exec.js\"></script>\n<script src=\"assert/run_main.js\"></script>\n</body>\n</html>",Name: "index.html",IsFile: true,}, File{IsDir: true,Name: "component",Children: []File{File{Content: "package component\n\nimport (\n	\"fmt\"\n	\"github.com/TobiasYin/go_web_ui/dom\"\n	\"github.com/TobiasYin/go_web_ui/node\"\n	\"github.com/TobiasYin/go_web_ui/node/color\"\n	\"strconv\"\n)\n\ntype StatelessDemo struct {\n	Value string\n}\n\nfunc (sc StatelessDemo) GetNode(context *node.Context) node.Widget {\n	return node.Block{\n		Children: []node.Widget{\n			node.Text{\n				Content: sc.Value + \" Stateless\",\n			},\n			node.BR{},\n		},\n	}\n}\n\nfunc (sc StatelessDemo) Pack(context node.Context) node.Node {\n	return node.PackStateless(sc, context)\n}\n\ntype StatefulDemo struct {\n	Key   string\n	Value string\n	Child node.Widget\n	Size  int\n}\n\nfunc (sc StatefulDemo) Pack(context node.Context) node.Node {\n	return node.PackStateful(sc, context)\n}\n\nfunc (sc StatefulDemo) GetKey() string {\n	if sc.Key != \"\" {\n		return sc.Key\n	}\n	if sc.Value != \"\" {\n		return sc.Value\n	}\n	return strconv.Itoa(sc.Size)\n}\n\nfunc (sc StatefulDemo) GetConstructor() node.ComponentConstructor {\n	size := sc.Size\n	return func(this *node.Context) node.Widget {\n		return node.Block{\n			Children: []node.Widget{\n				node.Text{\n					Content: \"Text ComponentFunc \" + sc.Value,\n					TextStyle: node.TextStyle{\n						Color:      color.RoyalBlue,\n						FontSize:   size,\n						FontWeight: node.FontWeight900,\n					},\n				},\n				node.BR{},\n				node.Text{\n					Content: fmt.Sprintf(\"size: %d\", size),\n				},\n				node.Button{\n					Child: node.Text{\n						Content: \"add\",\n					},\n					Params: node.Params{\n						OnClick: func(e dom.Event) {\n							this.SetState(func() {\n								size += 1\n								fmt.Printf(\"Push Button, size:%v\\n\", size)\n							})\n						},\n					},\n				},\n				sc.Child,\n			},\n		}\n	}\n}\n",Name: "component.go",IsFile: true,},},}, File{IsDir: true,Name: "assert",Children: []File{File{Content: ".go-ui-inline-div {\n    display: inline-block;\n}\n\n.go-ui-column {\n    display: flex;\n    flex-direction: column;\n}\n\n.go-ui-row {\n    display: inline-flex;\n    flex-direction: row;\n}",Name: "go-ui-basic.css",IsFile: true,}, File{Content: "let main =function () {\n    if (!WebAssembly.instantiateStreaming) {\n        WebAssembly.instantiateStreaming = async (resp, importObject) => {\n            const source = await (await resp).arrayBuffer();\n            return await WebAssembly.instantiate(source, importObject);\n        };\n    }\n\n    const go = new Go();\n    let mod, inst;\n    WebAssembly.instantiateStreaming(fetch('main.wasm'), go.importObject).then(async (result) => {\n        mod = result.module;\n        inst = result.instance;\n        await go.run(inst);\n    });\n}\nmain()",Name: "run_main.js",IsFile: true,}, File{Content: "// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n(() => {\n    // Map multiple JavaScript environments to a single common API,\n    // preferring web standards over Node.js API.\n    //\n    // Environments considered:\n    // - Browsers\n    // - Node.js\n    // - Electron\n    // - Parcel\n\n    if (typeof global !== \"undefined\") {\n        // global already exists\n    } else if (typeof window !== \"undefined\") {\n        window.global = window;\n    } else if (typeof self !== \"undefined\") {\n        self.global = self;\n    } else {\n        throw new Error(\"cannot export Go (neither global, window nor self is defined)\");\n    }\n\n    if (!global.require && typeof require !== \"undefined\") {\n        global.require = require;\n    }\n\n    if (!global.fs && global.require) {\n        const fs = require(\"fs\");\n        if (Object.keys(fs) !== 0) {\n            global.fs = fs;\n        }\n    }\n\n    const enosys = () => {\n        const err = new Error(\"not implemented\");\n        err.code = \"ENOSYS\";\n        return err;\n    };\n\n    if (!global.fs) {\n        let outputBuf = \"\";\n        global.fs = {\n            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, // unused\n            writeSync(fd, buf) {\n                outputBuf += decoder.decode(buf);\n                const nl = outputBuf.lastIndexOf(\"\\n\");\n                if (nl != -1) {\n                    console.log(outputBuf.substr(0, nl));\n                    outputBuf = outputBuf.substr(nl + 1);\n                }\n                return buf.length;\n            },\n            write(fd, buf, offset, length, position, callback) {\n                if (offset !== 0 || length !== buf.length || position !== null) {\n                    callback(enosys());\n                    return;\n                }\n                const n = this.writeSync(fd, buf);\n                callback(null, n);\n            },\n            chmod(path, mode, callback) { callback(enosys()); },\n            chown(path, uid, gid, callback) { callback(enosys()); },\n            close(fd, callback) { callback(enosys()); },\n            fchmod(fd, mode, callback) { callback(enosys()); },\n            fchown(fd, uid, gid, callback) { callback(enosys()); },\n            fstat(fd, callback) { callback(enosys()); },\n            fsync(fd, callback) { callback(null); },\n            ftruncate(fd, length, callback) { callback(enosys()); },\n            lchown(path, uid, gid, callback) { callback(enosys()); },\n            link(path, link, callback) { callback(enosys()); },\n            lstat(path, callback) { callback(enosys()); },\n            mkdir(path, perm, callback) { callback(enosys()); },\n            open(path, flags, mode, callback) { callback(enosys()); },\n            read(fd, buffer, offset, length, position, callback) { callback(enosys()); },\n            readdir(path, callback) { callback(enosys()); },\n            readlink(path, callback) { callback(enosys()); },\n            rename(from, to, callback) { callback(enosys()); },\n            rmdir(path, callback) { callback(enosys()); },\n            stat(path, callback) { callback(enosys()); },\n            symlink(path, link, callback) { callback(enosys()); },\n            truncate(path, length, callback) { callback(enosys()); },\n            unlink(path, callback) { callback(enosys()); },\n            utimes(path, atime, mtime, callback) { callback(enosys()); },\n        };\n    }\n\n    if (!global.process) {\n        global.process = {\n            getuid() { return -1; },\n            getgid() { return -1; },\n            geteuid() { return -1; },\n            getegid() { return -1; },\n            getgroups() { throw enosys(); },\n            pid: -1,\n            ppid: -1,\n            umask() { throw enosys(); },\n            cwd() { throw enosys(); },\n            chdir() { throw enosys(); },\n        }\n    }\n\n    if (!global.crypto) {\n        const nodeCrypto = require(\"crypto\");\n        global.crypto = {\n            getRandomValues(b) {\n                nodeCrypto.randomFillSync(b);\n            },\n        };\n    }\n\n    if (!global.performance) {\n        global.performance = {\n            now() {\n                const [sec, nsec] = process.hrtime();\n                return sec * 1000 + nsec / 1000000;\n            },\n        };\n    }\n\n    if (!global.TextEncoder) {\n        global.TextEncoder = require(\"util\").TextEncoder;\n    }\n\n    if (!global.TextDecoder) {\n        global.TextDecoder = require(\"util\").TextDecoder;\n    }\n\n    // End of polyfills for common API.\n\n    const encoder = new TextEncoder(\"utf-8\");\n    const decoder = new TextDecoder(\"utf-8\");\n\n    global.Go = class {\n        constructor() {\n            this.argv = [\"js\"];\n            this.env = {};\n            this.exit = (code) => {\n                if (code !== 0) {\n                    console.warn(\"exit code:\", code);\n                }\n            };\n            this._exitPromise = new Promise((resolve) => {\n                this._resolveExitPromise = resolve;\n            });\n            this._pendingEvent = null;\n            this._scheduledTimeouts = new Map();\n            this._nextCallbackTimeoutID = 1;\n\n            const setInt64 = (addr, v) => {\n                this.mem.setUint32(addr + 0, v, true);\n                this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n            }\n\n            const getInt64 = (addr) => {\n                const low = this.mem.getUint32(addr + 0, true);\n                const high = this.mem.getInt32(addr + 4, true);\n                return low + high * 4294967296;\n            }\n\n            const loadValue = (addr) => {\n                const f = this.mem.getFloat64(addr, true);\n                if (f === 0) {\n                    return undefined;\n                }\n                if (!isNaN(f)) {\n                    return f;\n                }\n\n                const id = this.mem.getUint32(addr, true);\n                return this._values[id];\n            }\n\n            const storeValue = (addr, v) => {\n                const nanHead = 0x7FF80000;\n\n                if (typeof v === \"number\") {\n                    if (isNaN(v)) {\n                        this.mem.setUint32(addr + 4, nanHead, true);\n                        this.mem.setUint32(addr, 0, true);\n                        return;\n                    }\n                    if (v === 0) {\n                        this.mem.setUint32(addr + 4, nanHead, true);\n                        this.mem.setUint32(addr, 1, true);\n                        return;\n                    }\n                    this.mem.setFloat64(addr, v, true);\n                    return;\n                }\n\n                switch (v) {\n                    case undefined:\n                        this.mem.setFloat64(addr, 0, true);\n                        return;\n                    case null:\n                        this.mem.setUint32(addr + 4, nanHead, true);\n                        this.mem.setUint32(addr, 2, true);\n                        return;\n                    case true:\n                        this.mem.setUint32(addr + 4, nanHead, true);\n                        this.mem.setUint32(addr, 3, true);\n                        return;\n                    case false:\n                        this.mem.setUint32(addr + 4, nanHead, true);\n                        this.mem.setUint32(addr, 4, true);\n                        return;\n                }\n\n                let id = this._ids.get(v);\n                if (id === undefined) {\n                    id = this._idPool.pop();\n                    if (id === undefined) {\n                        id = this._values.length;\n                    }\n                    this._values[id] = v;\n                    this._goRefCounts[id] = 0;\n                    this._ids.set(v, id);\n                }\n                this._goRefCounts[id]++;\n                let typeFlag = 1;\n                switch (typeof v) {\n                    case \"string\":\n                        typeFlag = 2;\n                        break;\n                    case \"symbol\":\n                        typeFlag = 3;\n                        break;\n                    case \"function\":\n                        typeFlag = 4;\n                        break;\n                }\n                this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n                this.mem.setUint32(addr, id, true);\n            }\n\n            const loadSlice = (addr) => {\n                const array = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n            }\n\n            const loadSliceOfValues = (addr) => {\n                const array = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                const a = new Array(len);\n                for (let i = 0; i < len; i++) {\n                    a[i] = loadValue(array + i * 8);\n                }\n                return a;\n            }\n\n            const loadString = (addr) => {\n                const saddr = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n            }\n\n            const timeOrigin = Date.now() - performance.now();\n            this.importObject = {\n                go: {\n                    // Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n                    // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n                    // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n                    // This changes the SP, thus we have to update the SP used by the imported function.\n\n                    // func wasmExit(code int32)\n                    \"runtime.wasmExit\": (sp) => {\n                        const code = this.mem.getInt32(sp + 8, true);\n                        this.exited = true;\n                        delete this._inst;\n                        delete this._values;\n                        delete this._goRefCounts;\n                        delete this._ids;\n                        delete this._idPool;\n                        this.exit(code);\n                    },\n\n                    // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n                    \"runtime.wasmWrite\": (sp) => {\n                        const fd = getInt64(sp + 8);\n                        const p = getInt64(sp + 16);\n                        const n = this.mem.getInt32(sp + 24, true);\n                        fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n                    },\n\n                    // func resetMemoryDataView()\n                    \"runtime.resetMemoryDataView\": (sp) => {\n                        this.mem = new DataView(this._inst.exports.mem.buffer);\n                    },\n\n                    // func nanotime1() int64\n                    \"runtime.nanotime1\": (sp) => {\n                        setInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);\n                    },\n\n                    // func walltime1() (sec int64, nsec int32)\n                    \"runtime.walltime1\": (sp) => {\n                        const msec = (new Date).getTime();\n                        setInt64(sp + 8, msec / 1000);\n                        this.mem.setInt32(sp + 16, (msec % 1000) * 1000000, true);\n                    },\n\n                    // func scheduleTimeoutEvent(delay int64) int32\n                    \"runtime.scheduleTimeoutEvent\": (sp) => {\n                        const id = this._nextCallbackTimeoutID;\n                        this._nextCallbackTimeoutID++;\n                        this._scheduledTimeouts.set(id, setTimeout(\n                            () => {\n                                this._resume();\n                                while (this._scheduledTimeouts.has(id)) {\n                                    // for some reason Go failed to register the timeout event, log and try again\n                                    // (temporary workaround for https://github.com/golang/go/issues/28975)\n                                    console.warn(\"scheduleTimeoutEvent: missed timeout event\");\n                                    this._resume();\n                                }\n                            },\n                            getInt64(sp + 8) + 1, // setTimeout has been seen to fire up to 1 millisecond early\n                        ));\n                        this.mem.setInt32(sp + 16, id, true);\n                    },\n\n                    // func clearTimeoutEvent(id int32)\n                    \"runtime.clearTimeoutEvent\": (sp) => {\n                        const id = this.mem.getInt32(sp + 8, true);\n                        clearTimeout(this._scheduledTimeouts.get(id));\n                        this._scheduledTimeouts.delete(id);\n                    },\n\n                    // func getRandomData(r []byte)\n                    \"runtime.getRandomData\": (sp) => {\n                        crypto.getRandomValues(loadSlice(sp + 8));\n                    },\n\n                    // func finalizeRef(v ref)\n                    \"syscall/js.finalizeRef\": (sp) => {\n                        const id = this.mem.getUint32(sp + 8, true);\n                        this._goRefCounts[id]--;\n                        if (this._goRefCounts[id] === 0) {\n                            const v = this._values[id];\n                            this._values[id] = null;\n                            this._ids.delete(v);\n                            this._idPool.push(id);\n                        }\n                    },\n\n                    // func stringVal(value string) ref\n                    \"syscall/js.stringVal\": (sp) => {\n                        storeValue(sp + 24, loadString(sp + 8));\n                    },\n\n                    // func valueGet(v ref, p string) ref\n                    \"syscall/js.valueGet\": (sp) => {\n                        const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                        sp = this._inst.exports.getsp(); // see comment above\n                        storeValue(sp + 32, result);\n                    },\n\n                    // func valueSet(v ref, p string, x ref)\n                    \"syscall/js.valueSet\": (sp) => {\n                        Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                    },\n\n                    // func valueDelete(v ref, p string)\n                    \"syscall/js.valueDelete\": (sp) => {\n                        Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                    },\n\n                    // func valueIndex(v ref, i int) ref\n                    \"syscall/js.valueIndex\": (sp) => {\n                        storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                    },\n\n                    // valueSetIndex(v ref, i int, x ref)\n                    \"syscall/js.valueSetIndex\": (sp) => {\n                        Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                    },\n\n                    // func valueCall(v ref, m string, args []ref) (ref, bool)\n                    \"syscall/js.valueCall\": (sp) => {\n                        try {\n                            const v = loadValue(sp + 8);\n                            const m = Reflect.get(v, loadString(sp + 16));\n                            const args = loadSliceOfValues(sp + 32);\n                            const result = Reflect.apply(m, v, args);\n                            sp = this._inst.exports.getsp(); // see comment above\n                            storeValue(sp + 56, result);\n                            this.mem.setUint8(sp + 64, 1);\n                        } catch (err) {\n                            storeValue(sp + 56, err);\n                            this.mem.setUint8(sp + 64, 0);\n                        }\n                    },\n\n                    // func valueInvoke(v ref, args []ref) (ref, bool)\n                    \"syscall/js.valueInvoke\": (sp) => {\n                        try {\n                            const v = loadValue(sp + 8);\n                            const args = loadSliceOfValues(sp + 16);\n                            const result = Reflect.apply(v, undefined, args);\n                            sp = this._inst.exports.getsp(); // see comment above\n                            storeValue(sp + 40, result);\n                            this.mem.setUint8(sp + 48, 1);\n                        } catch (err) {\n                            storeValue(sp + 40, err);\n                            this.mem.setUint8(sp + 48, 0);\n                        }\n                    },\n\n                    // func valueNew(v ref, args []ref) (ref, bool)\n                    \"syscall/js.valueNew\": (sp) => {\n                        try {\n                            const v = loadValue(sp + 8);\n                            const args = loadSliceOfValues(sp + 16);\n                            const result = Reflect.construct(v, args);\n                            sp = this._inst.exports.getsp(); // see comment above\n                            storeValue(sp + 40, result);\n                            this.mem.setUint8(sp + 48, 1);\n                        } catch (err) {\n                            storeValue(sp + 40, err);\n                            this.mem.setUint8(sp + 48, 0);\n                        }\n                    },\n\n                    // func valueLength(v ref) int\n                    \"syscall/js.valueLength\": (sp) => {\n                        setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                    },\n\n                    // valuePrepareString(v ref) (ref, int)\n                    \"syscall/js.valuePrepareString\": (sp) => {\n                        const str = encoder.encode(String(loadValue(sp + 8)));\n                        storeValue(sp + 16, str);\n                        setInt64(sp + 24, str.length);\n                    },\n\n                    // valueLoadString(v ref, b []byte)\n                    \"syscall/js.valueLoadString\": (sp) => {\n                        const str = loadValue(sp + 8);\n                        loadSlice(sp + 16).set(str);\n                    },\n\n                    // func valueInstanceOf(v ref, t ref) bool\n                    \"syscall/js.valueInstanceOf\": (sp) => {\n                        this.mem.setUint8(sp + 24, (loadValue(sp + 8) instanceof loadValue(sp + 16)) ? 1 : 0);\n                    },\n\n                    // func copyBytesToGo(dst []byte, src ref) (int, bool)\n                    \"syscall/js.copyBytesToGo\": (sp) => {\n                        const dst = loadSlice(sp + 8);\n                        const src = loadValue(sp + 32);\n                        if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                            this.mem.setUint8(sp + 48, 0);\n                            return;\n                        }\n                        const toCopy = src.subarray(0, dst.length);\n                        dst.set(toCopy);\n                        setInt64(sp + 40, toCopy.length);\n                        this.mem.setUint8(sp + 48, 1);\n                    },\n\n                    // func copyBytesToJS(dst ref, src []byte) (int, bool)\n                    \"syscall/js.copyBytesToJS\": (sp) => {\n                        const dst = loadValue(sp + 8);\n                        const src = loadSlice(sp + 16);\n                        if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                            this.mem.setUint8(sp + 48, 0);\n                            return;\n                        }\n                        const toCopy = src.subarray(0, dst.length);\n                        dst.set(toCopy);\n                        setInt64(sp + 40, toCopy.length);\n                        this.mem.setUint8(sp + 48, 1);\n                    },\n\n                    \"debug\": (value) => {\n                        console.log(value);\n                    },\n                }\n            };\n        }\n\n        async run(instance) {\n            this._inst = instance;\n            this.mem = new DataView(this._inst.exports.mem.buffer);\n            this._values = [ // JS values that Go currently has references to, indexed by reference id\n                NaN,\n                0,\n                null,\n                true,\n                false,\n                global,\n                this,\n            ];\n            this._goRefCounts = []; // number of references that Go has to a JS value, indexed by reference id\n            this._ids = new Map();  // mapping from JS values to reference ids\n            this._idPool = [];      // unused ids that have been garbage collected\n            this.exited = false;    // whether the Go program has exited\n\n            // Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n            let offset = 4096;\n\n            const strPtr = (str) => {\n                const ptr = offset;\n                const bytes = encoder.encode(str + \"\\0\");\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n                offset += bytes.length;\n                if (offset % 8 !== 0) {\n                    offset += 8 - (offset % 8);\n                }\n                return ptr;\n            };\n\n            const argc = this.argv.length;\n\n            const argvPtrs = [];\n            this.argv.forEach((arg) => {\n                argvPtrs.push(strPtr(arg));\n            });\n            argvPtrs.push(0);\n\n            const keys = Object.keys(this.env).sort();\n            keys.forEach((key) => {\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n            });\n            argvPtrs.push(0);\n\n            const argv = offset;\n            argvPtrs.forEach((ptr) => {\n                this.mem.setUint32(offset, ptr, true);\n                this.mem.setUint32(offset + 4, 0, true);\n                offset += 8;\n            });\n\n            this._inst.exports.run(argc, argv);\n            if (this.exited) {\n                this._resolveExitPromise();\n            }\n            await this._exitPromise;\n        }\n\n        _resume() {\n            if (this.exited) {\n                throw new Error(\"Go program has already exited\");\n            }\n            this._inst.exports.resume();\n            if (this.exited) {\n                this._resolveExitPromise();\n            }\n        }\n\n        _makeFuncWrapper(id) {\n            const go = this;\n            return function () {\n                const event = { id: id, this: this, args: arguments };\n                go._pendingEvent = event;\n                go._resume();\n                return event.result;\n            };\n        }\n    }\n\n    if (\n        global.require &&\n        global.require.main === module &&\n        global.process &&\n        global.process.versions &&\n        !global.process.versions.electron\n    ) {\n        if (process.argv.length < 3) {\n            console.error(\"usage: go_js_wasm_exec [wasm binary] [arguments]\");\n            process.exit(1);\n        }\n\n        const go = new Go();\n        go.argv = process.argv.slice(2);\n        go.env = Object.assign({ TMPDIR: require(\"os\").tmpdir() }, process.env);\n        go.exit = process.exit;\n        WebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject).then((result) => {\n            process.on(\"exit\", (code) => { // Node.js exits if no event handler is pending\n                if (code === 0 && !go.exited) {\n                    // deadlock, make Go print error and stack traces\n                    go._pendingEvent = { id: 0 };\n                    go._resume();\n                }\n            });\n            return go.run(result.instance);\n        }).catch((err) => {\n            console.error(err);\n            process.exit(1);\n        });\n    }\n})();",Name: "wasm_exec.js",IsFile: true,},},}, File{Content: "#!/usr/bin/env bash\ncd {{PROJECT_PATH}}\nif [ ! -d  \"output\" ]; then\n  echo \"Create Static File\"\n  mkdir output  2> /dev/null\n  cp -r assert output/ 2> /dev/null\n  cp index.html output 2> /dev/null\nelse\n  echo \"Static Exist, Compile Only\"\nfi\ngo get -d github.com/TobiasYin/go_web_ui\nGOARCH=wasm GOOS=js go build -o output/main.wasm main.go\n",Name: "build.sh",IsFile: true,}, File{IsDir: true,Name: "urls",Children: []File{File{Content: "package urls\n\nimport (\n	\"github.com/TobiasYin/go_web_ui/node\"\n	pages \"github.com/TobiasYin/go_web_ui/tool/template/page\"\n)\n\nfunc init() {\n	node.RegisterRoute(\"/image\", pages.NewImagePage)\n}\n",Name: "init.go",IsFile: true,},},}, File{Content: "package main\n\nimport (\n	\"github.com/TobiasYin/go_web_ui/node\"\n	pages \"github.com/TobiasYin/go_web_ui/tool/template/page\"\n	_ \"github.com/TobiasYin/go_web_ui/tool/template/urls\"\n)\n\nfunc main() {\n	node.NewApp(pages.GetMainPage())\n}\n",Name: "main.go",IsFile: true,},},}}